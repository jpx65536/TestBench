清零容器、卷等数据，再重新跑
docker compose down
# 如果刚刚是刚起就秒退，通常没有有效数据，可以清卷
docker volume rm mysql-ha_master_data mysql-ha_replica1_data mysql-ha_replica2_data 2>/dev/null
docker compose up -d

配置复制
docker exec -it replica1 mysql -uroot -proot_pass -e "
STOP REPLICA;
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST='master',
  SOURCE_PORT=3306,
  SOURCE_USER='repl',
  SOURCE_PASSWORD='repl_pass',
  SOURCE_AUTO_POSITION=1;
START REPLICA; SHOW REPLICA STATUS\G"

# replica2
docker exec -it replica2 mysql -uroot -proot_pass -e "
STOP REPLICA;
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST='master',
  SOURCE_PORT=3306,
  SOURCE_USER='repl',
  SOURCE_PASSWORD='repl_pass',
  SOURCE_AUTO_POSITION=1;
START REPLICA; SHOW REPLICA STATUS\G"

安装并启用半同步
主库
docker exec -it master mysql -uroot -proot_pass -e "
INSTALL PLUGIN rpl_semi_sync_source SONAME 'semisync_source.so';
SET PERSIST rpl_semi_sync_source_enabled=ON;
SET PERSIST rpl_semi_sync_source_timeout=1000;
SET PERSIST rpl_semi_sync_source_wait_for_replica_count=1;
"
校验主库插件与变量
docker exec -it master mysql -uroot -proot_pass -e "
SELECT PLUGIN_NAME, PLUGIN_STATUS
FROM information_schema.PLUGINS
WHERE PLUGIN_NAME LIKE 'rpl_semi%';

SHOW VARIABLES LIKE 'rpl_semi_sync_source%';
SHOW STATUS LIKE 'Rpl_semi_sync_source%';
"
预期：PLUGIN_STATUS 为 ACTIVE；Rpl_semi_sync_source_status 在至少有一个半同步副本在线时会变为 ON，Rpl_semi_sync_source_clients > 0。

从库安装并启用
先关闭只读，然后安装，然后让半同步生效，最后再开启只读：
for n in replica1 replica2; do
  # 1) 先解只读
  docker exec -i "$n" mysql -uroot -proot_pass -e "
    SET SESSION sql_log_bin=0;
    SET GLOBAL super_read_only=OFF;
    SET GLOBAL read_only=OFF;"

  # 2) 安装插件（已装会报错，忽略即可）
  docker exec -i "$n" mysql -uroot -proot_pass -e "
    INSTALL PLUGIN rpl_semi_sync_replica SONAME 'semisync_replica.so';" \
    || echo "$n: plugin already installed (ok)"

  # 3) 启用并恢复只读
  docker exec -i "$n" mysql -uroot -proot_pass -e "
    SET GLOBAL  rpl_semi_sync_replica_enabled = ON;
    SET PERSIST rpl_semi_sync_replica_enabled = ON;
    SET GLOBAL read_only=ON;
    SET GLOBAL super_read_only=ON;"

  # 4) IO 线程重连，让半同步协商立即生效
  docker exec -it "$n" mysql -uroot -proot_pass -e "
    STOP REPLICA IO_THREAD; START REPLICA IO_THREAD;"
done


主库确认生效
docker exec -it master mysql -uroot -proot_pass -e "
SHOW VARIABLES LIKE 'rpl_semi_sync_source_enabled';
SHOW STATUS LIKE 'Rpl_semi_sync_source_status';
SHOW STATUS LIKE 'Rpl_semi_sync_source_clients';"
"

期望：rpl_semi_sync_source_enabled = ON，Rpl_semi_sync_source_status = ON，Rpl_semi_sync_source_clients >= 1（两个从库的话通常是 2）。
+-----------------------------+-------+
| Variable_name               | Value |
+-----------------------------+-------+
| Rpl_semi_sync_source_status | ON    |
+-----------------------------+-------+
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| Rpl_semi_sync_source_clients | 2     |
+------------------------------+-------+

ProxySQL 装入配置并保存
docker exec -it proxysql mysql -uadmin -padmin -h 127.0.0.1 -P6032 -e "
LOAD MYSQL VARIABLES TO RUNTIME;      SAVE MYSQL VARIABLES TO DISK;
LOAD MYSQL SERVERS TO RUNTIME;        SAVE MYSQL SERVERS TO DISK;
LOAD MYSQL USERS TO RUNTIME;          SAVE MYSQL USERS TO DISK;
LOAD MYSQL QUERY RULES TO RUNTIME;    SAVE MYSQL QUERY RULES TO DISK;
SELECT hostgroup_id,hostname,port,status FROM runtime_mysql_servers;
"
自检看运行时服务器/hostgroup映射是否在
# 运行态的后端实例
docker exec -it proxysql mysql -uadmin -padmin -h127.0.0.1 -P6032 -e \
"SELECT hostgroup_id,hostname,port,status FROM runtime_mysql_servers;"
+--------------+----------+------+--------+
| hostgroup_id | hostname | port | status |
+--------------+----------+------+--------+
| 10           | master   | 3306 | ONLINE |
| 20           | replica1 | 3306 | ONLINE |
| 20           | replica2 | 3306 | ONLINE |
+--------------+----------+------+--------+
写库组（10）里只有 master 且 ONLINE。
读库组（20）里有 replica1/replica2 且都 ONLINE。
→ 后端节点加载成功，健康探测通过。

# 运行态的复制分组（确认 10/20 的绑定）
docker exec -it proxysql mysql -uadmin -padmin -h127.0.0.1 -P6032 -e \
"SELECT * FROM runtime_mysql_replication_hostgroups;"

+------------------+------------------+------------+-----------------+
| writer_hostgroup | reader_hostgroup | check_type | comment         |
+------------------+------------------+------------+-----------------+
| 10               | 20               | READ_ONLY  | rw-split mysql8 |
+------------------+------------------+------------+-----------------+
复制分组映射为 10↔20，用 read_only 位判定主从。
→ ProxySQL 知道谁是写、谁是读，并会自动摘除不健康/延迟过大的读节点。

验收：写一次，读2次，读的落在replica1上了；
mysql -uappuser -papp_pass -h127.0.0.1 -P6033 -e "INSERT INTO appdb.users(name) VALUES('via_psql');"
mysql -uappuser -papp_pass -h127.0.0.1 -P6033 -e "SELECT COUNT(*) FROM appdb.users;"
mysql -uappuser -papp_pass -h127.0.0.1 -P6033 -e "SELECT /*force_writer*/ COUNT(*) FROM appdb.users;"
docker exec -it proxysql mysql -uadmin -padmin -h127.0.0.1 -P6032 -e \
"SELECT hostgroup,srv_host,status,ConnUsed,Queries FROM stats_mysql_connection_pool ORDER BY hostgroup,srv_host;"
+-----------+----------+--------+----------+---------+
| hostgroup | srv_host | status | ConnUsed | Queries |
+-----------+----------+--------+----------+---------+
| 10        | master   | ONLINE | 0        | 1       |
| 20        | replica1 | ONLINE | 0        | 2       |
| 20        | replica2 | ONLINE | 0        | 0       |
+-----------+----------+--------+----------+---------+

验收：连续跑 10 次 SELECT COUNT(*) ... 看是否会轮到 replica2；
先清零：
docker exec -it proxysql mysql -uadmin -padmin -h127.0.0.1 -P6032 -e "
SELECT * FROM stats_mysql_connection_pool_reset;
-- 只看读库 hostgroup=20 的当前计数
SELECT hostgroup,srv_host,status,ConnUsed,Queries
FROM stats_mysql_connection_pool
WHERE hostgroup=20
ORDER BY srv_host;
"
连续跑10次：
for i in {1..10}; do
  mysql -uappuser -papp_pass -h127.0.0.1 -P6033 -e "SELECT COUNT(*) FROM appdb.users;" >/dev/null
done

查看分发结果：
docker exec -it proxysql mysql -uadmin -padmin -h127.0.0.1 -P6032 -e "
SELECT hostgroup,srv_host,status,ConnUsed,Queries
FROM stats_mysql_connection_pool
WHERE hostgroup=20
ORDER BY srv_host;
"
![img.png](docs/images/img.png)